package cn.poile.ucs.auth.config;//import cn.poile.ucs.auth.convert.CustomUserAuthenticationConverter;import cn.poile.ucs.auth.convert.CustomUserAuthenticationConverter;import cn.poile.ucs.auth.convert.JwtAccessToken;import cn.poile.ucs.auth.granter.MobileCodeTokenGranter;import cn.poile.ucs.auth.security.UserDetailsServiceImpl;import cn.poile.ucs.auth.vo.UserDetailImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.bootstrap.encrypt.KeyProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.oauth2.common.DefaultOAuth2AccessToken;import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;import org.springframework.security.oauth2.provider.ClientDetailsService;import org.springframework.security.oauth2.provider.CompositeTokenGranter;import org.springframework.security.oauth2.provider.TokenGranter;import org.springframework.security.oauth2.provider.client.JdbcClientDetailsService;import org.springframework.security.oauth2.provider.code.AuthorizationCodeServices;import org.springframework.security.oauth2.provider.code.AuthorizationCodeTokenGranter;import org.springframework.security.oauth2.provider.implicit.ImplicitTokenGranter;import org.springframework.security.oauth2.provider.password.ResourceOwnerPasswordTokenGranter;import org.springframework.security.oauth2.provider.refresh.RefreshTokenGranter;import org.springframework.security.oauth2.provider.token.*;import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;import org.springframework.security.oauth2.provider.token.store.KeyStoreKeyFactory;import javax.annotation.Resource;import javax.sql.DataSource;import java.security.KeyPair;import java.util.*;import java.util.concurrent.TimeUnit;/** * 认证配置 * @author: yaohw * @create: 2019-09-30 16:12 **/@Configuration@EnableAuthorizationServerpublic class AuthorizationConfig extends AuthorizationServerConfigurerAdapter {    @Autowired    private AuthenticationManager authenticationManager;    @Autowired    private UserDetailsServiceImpl userDetailsService;    @Autowired    private CustomUserAuthenticationConverter customUserAuthenticationConverter;    @Autowired    private RedisConnectionFactory redisConnectionFactory;    @Autowired    DataSource dataSource;    @Autowired    TokenStore tokenStore;    /**     * jwt令牌转换器     */    @Autowired    private JwtAccessToken jwtAccessTokenConverter;    @Override    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {        // 采用token转jwt，并添加一些自定义信息（token增强）（有默认非必须）        TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();        tokenEnhancerChain.setTokenEnhancers(                //将普通 OAuth2 令牌转换为 JWT 格式，支持令牌签名和验证                Arrays.asList( tokenEnhancer(),jwtAccessTokenConverter(customUserAuthenticationConverter)));        endpoints.tokenEnhancer(tokenEnhancerChain)                // 配置token存储，一般配置redis存储                .tokenStore(tokenStore)                // 配置认证管理器                .authenticationManager(authenticationManager)//                .accessTokenConverter(jwtAccessTokenConverter)                // 配置用户详情server，密码模式必须                .userDetailsService(userDetailsService)                // 配置授权码模式授权码服务,不配置默认为内存模式                .authorizationCodeServices(authorizationCodeServices())                // 配置grant_type模式，如果不配置则默认使用密码模式、简化模式、验证码模式以及刷新token模式，如果配置了只使用配置中，默认配置失效                // 具体可以查询AuthorizationServerEndpointsConfigurer中的getDefaultTokenGranters方法                .tokenGranter(tokenGranter(endpoints));        // 配置TokenServices参数        DefaultTokenServices tokenServices = new DefaultTokenServices();        tokenServices.setTokenStore(endpoints.getTokenStore());        // 是否支持刷新Token        tokenServices.setSupportRefreshToken(true);        tokenServices.setReuseRefreshToken(true);        tokenServices.setClientDetailsService(endpoints.getClientDetailsService());        tokenServices.setTokenEnhancer(endpoints.getTokenEnhancer());        // 设置accessToken和refreshToken的默认超时时间(如果clientDetails的为null就取默认的，如果clientDetails的不为null取clientDetails中的)        tokenServices.setAccessTokenValiditySeconds((int) TimeUnit.HOURS.toSeconds(2));        tokenServices.setRefreshTokenValiditySeconds((int) TimeUnit.DAYS.toSeconds(30));        endpoints.tokenServices(tokenServices);    }    /**     * 配置授权码模式授权码服务,不配置默认为内存模式     * @return     */    @Primary    @Bean    public AuthorizationCodeServices authorizationCodeServices() {        return new RedisAuthorizationCodeServices(redisConnectionFactory);    }    @Bean    @Autowired    public TokenStore tokenStore(JwtAccessToken  jwtAccessTokenConverter) {        return new JwtTokenStore(jwtAccessTokenConverter);    }    @Bean("ClientDetailsService")    public ClientDetailsService clientDetails() {        return new JdbcClientDetailsService(dataSource);    }    /**     * 配置客户端详情     * @param clients     * @throws Exception     */    @Override    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {        clients.withClientDetails(clientDetails()); // 启用数据库方式    }    /**     * 读取密钥的配置     */    @Bean("keyProp")    public KeyProperties keyProperties() {        return new KeyProperties();    }    @Resource(name = "keyProp")    private KeyProperties keyProperties;    /**     * 使用非对称加密算法来对Token进行签名     *     * @return 装换器     */    @Bean    public JwtAccessTokenConverter jwtAccessTokenConverter(CustomUserAuthenticationConverter customUserAuthenticationConverter) {        final JwtAccessToken converter = new JwtAccessToken(); // 改为自定义子类        // 导入证书        KeyPair keyPair = new KeyStoreKeyFactory                (keyProperties.getKeyStore().getLocation(), keyProperties.getKeyStore().getSecret().toCharArray())                .getKeyPair(keyProperties.getKeyStore().getAlias(), keyProperties.getKeyStore().getPassword().toCharArray());        converter.setKeyPair(keyPair);        // 配置用户认证转换器（原有逻辑不变）        DefaultAccessTokenConverter accessTokenConverter = (DefaultAccessTokenConverter) converter.getAccessTokenConverter();        accessTokenConverter.setUserTokenConverter(customUserAuthenticationConverter);        return converter;    }    /**     * token增强,添加一些元信息  这里增强获取token的时候会携带增强的内容     *     * @return TokenEnhancer     */    @Bean    public TokenEnhancer tokenEnhancer() {        return (accessToken, authentication) -> {            final Map<String, Object> additionalInfo = new HashMap<>();            // 添加自定义信息            additionalInfo.put("license", "yaohw");            ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInfo);            return accessToken;        };    }    @Override    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {        security                //允许客户端使用表单认证                .allowFormAuthenticationForClients()                //配置获取公钥端点（/oauth/token_key）的访问权限                .tokenKeyAccess("permitAll()")                //配置令牌验证端点（/oauth/check_token）的访问权限                .checkTokenAccess("isAuthenticated()");    }    /**     * 创建grant_type列表     * @param endpoints     * @return     */    private TokenGranter tokenGranter(AuthorizationServerEndpointsConfigurer endpoints) {        List<TokenGranter> list = new ArrayList<>();        // 这里配置密码模式、刷新token模式、自定义手机号验证码模式、授权码模式、简化模式        list.add(new ResourceOwnerPasswordTokenGranter(authenticationManager, endpoints.getTokenServices(), endpoints.getClientDetailsService(), endpoints.getOAuth2RequestFactory()));        list.add(new RefreshTokenGranter(endpoints.getTokenServices(), endpoints.getClientDetailsService(), endpoints.getOAuth2RequestFactory()));        list.add(new MobileCodeTokenGranter(authenticationManager, endpoints.getTokenServices(), endpoints.getClientDetailsService(), endpoints.getOAuth2RequestFactory()));        list.add(new AuthorizationCodeTokenGranter(endpoints.getTokenServices(), endpoints.getAuthorizationCodeServices(), endpoints.getClientDetailsService(), endpoints.getOAuth2RequestFactory()));        list.add(new ImplicitTokenGranter(endpoints.getTokenServices(), endpoints.getClientDetailsService(), endpoints.getOAuth2RequestFactory()));        return new CompositeTokenGranter(list);    }}